#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @File  : Cp4_1_3.py
# @Author: WRH
# @Date  : 2021/3/17
# @Edition:Python3.8.6

# 元组
'''
元组（tuple）是Python中另一种内置的存储有序数据的结构
元组是不可变的，这意味着一旦创建了元组，就不能修改或删除它的元素。
但是，如果元组中的元素包含了可变的对象，比如列表，那么元组的值可能会改变。这是因为元组只是存储了对象的引用，而不是对象本身。
注意：创建仅包括一个值的元组必须加个半角逗号
'''

# 1.创建元组
'''
创建元组的语法很简单：如果用逗号分隔了一些值，那么将自动创建元组，元组通常用圆括号()括起来。
换句话说，任意类型的对象，如果以逗号隔开，则默认为元组。
'''
# 如果用逗号分隔了一些值，那么将自动创建元组
tup = 1, 2, 3
print(tup)
tup = (1, 2, 3)  # 也可直接给变量名赋值元组
print(tup)
# 注意:创建仅包括一个值的元组必须加个半角逗号，因为不加逗号就成了一般的赋值语句
tup_2 = 42,
print(tup_2)

# 例4-9 元组创建举例。
tup1 = (1, 2, 3)
print(tup1)

tup2 = ('physics', 'chemistry', 1997, 2000)
print(tup2)

t = (12345, 54321, 'hello!')
u = t, (1, 2, 3, 4, 5)  # 元组允许嵌套
print(u)
# 注意输出结果是：((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))，
# 不是(12345, 54321, 'hello!',1, 2, 3, 4, 5)
print(u[1][2], u[0][2])  # 输出二维元组的元素。

v = ([1, 2, 3], ['a', 'b', 'c'])  # 元组中的元素可以为可修改的数据类型，比如列表
print(v)
print(v[1][1])
v[1][1] = 'd'  # 虽然元组是只读不可更改的，但其中的元素列表是可修改的
print(v)

tu = [(1, 2, 3), ('a', 'b', 'c')]
# tu[1][1] = 'd'       # 与上例相反，试图修改元组中元素是会报错的，运行此行会报错

# 2.元组的基本操作
'''
操 作	                            含 义
<tup>[i]	                        索引（求＜tup＞中位置索引为i的元素），索引值从0开始
<tup>[i:j:k]	                    切片（求＜tup＞中位置索引为i〜j,步长为k的子元组），取i不取j,k为负时倒序取值
<tup1>+<tup2>	                    将<tup1>和<tup2>连接
<tup>*<int-expr>或<int-expr>*<tup>	将 <tup> 复制 <int-expr>次
len(<seq>)	                        求长度
for<var>in<tup>:	                对<tup>中的元素循环进行循环操作
<expr> in <tup>或<expr> not in <tup>查找＜tup＞中是否存在＜expr＞,返回值为布尔类型
del <tup>	                        删除元组
max(<tup>)	                        返回元组中最大值
min(<tup>)	                        返回元组中最小值
<tup>.index(x)                      返回元组中值为x的元素第一次出现的位置索引，若不存在则出错。
'''

tup1 = ('火影忍者', '名侦探柯南', '魔道祖师', '狐妖小红娘')
tup2 = ('a', 'b', 'c')
tup3 = (1, 2, 3)
# 元组索引
print(tup1[1])
# 元组切片
print(tup1[-1:-3:-1])
# 元组连接
print(tup1 + tup2)
# 元组复制
print(tup1 * 2)
# 元组长度
print(len(tup1))
# 元组遍历
for i in tup1:
    print(i)
# 判断某元素是否在元祖中
print('火影忍者' in tup1)
print('c' not in tup2)
# 删除元组
del tup2
# print(tup2) # 元组被删除后，试图输出元组会报错
# 元祖中的最大值最小值
print(max(tup3), min(tup3))
# 元组中元素第一次出现时的索引
print(tup1.index('狐妖小红娘'))

# 不可对元组进行的操作
'''
由于元组是不可修改的，所以：
1.元组中的元素不允许修改
2.不能向元组增加元素，元组没有append或extend方法
3.不能从元组删除元素，元组没有remove或pop方法
'''
# 例4-10
'''
有一筐鸡蛋,1个1个拿，正好拿完；2个2个拿，还剩1个；3个3个拿，正好拿完；4个4个拿，还剩1个；
5个5个拿，还差1个；6个6个拿，还剩3个；7个7个拿，正好拿完；8个8个拿，还剩1个；9个9个拿，正好拿完。
问筐里最少有多少鸡蛋？
'''
# 方法一：
i = 0  # 假设框里一共有i个鸡蛋，设置初始判断值为0
while True:  # 设置循环语句
    if ((i % 1 == 0) and (i % 2 == 1) and (i % 3 == 0) and (i % 4 == 1) and (i % 5 == 4)
            and (i % 6 == 3) and (i % 7 == 0) and (i % 8 == 1) and (i % 9 == 0)):  # 将题干条件转写成代码
        print('i= ', i)  # 当以上条件都满足时输出i值
        break  # 退出整个循环
    i += 1  # i值每循环一次增加一个数，重新进入循环进行判断

# 方法二：
'''
（此知识点超纲，了解即可）
flag这一变量名常常被用于命名旗标变量，或者说哨兵变量。这种变量的作用体现在帮助进行条件判断中，
常常使用int类型变量中的0、1或布尔类型变量中的false（0）、true（1）来表示。
flag作为if的判断条件，原值为0，当满足while里的if语句，flag=1，即为找到满足if语句条件值，然后跳出循环
flag作为一个标识，如果找到了满足条件的值，那么在下面的if-else语句中将输出正确的值，否则表示没找到。
'''
i = 0  # 假设框里一共有i个鸡蛋，设置初始判断值为0
remain = (0, 1, 0, 1, 4, 3, 0, 1, 0)  # 将剩余结果数放入元组中
while True:  # 设置循环语句
    flag = 1  # 标识语句，在每一轮判别中都将flag设置为1，这里代表的含义是当前i默认为满足条件的数
    for j in range(1, 10):  # 生成数列1-9并进行遍历。1-9对应题干几个几个的拿
        if i % j != remain[j - 1]:  # 此语句为反向判断，如果取模除的结果中有一个不等于元组中对应的值，则i不是满足条件的数
            flag = 0  # 标识语句，i值满足上一行if的条件，继续进行循环判断
    if flag == 1:  # 标识语句，条件满足
        print('i= ', i)  # 输出i值
        break  # 退出整个循环
    i += 1  # i值每循环一次增加一个数，重新进入循环进行判断

# 3.元组与列表的相互转换
'''
元组与列表可以互相转换，Python内置的tuple()函数接收一个列表，可返回一个包含相同元素的元组。
而 list() 函数接收一个元组并返回一个列表。
从元组与列表的性质来看，tuple()相当于冻结一个列表，而list()相当于解冻一个元组。
'''
list1 = [1, 2, 3]
tup1 = tuple(list1)  # 将列表list1转换为元组
print(tup1)
print(list(tup1))  # 将元组tup1转换成元组并输出

# 利用列表解析语句实现列表与元组的转换
'''
列表解析（list comprehension），又叫列表推导式,常用于从集合对象中有选择地获取并计算元素。
列表解析比for更精简，运行更快，特别是对于较大的数据集合
列表解析元语法格式：
[expr for iter_var in iterable if cond_expr] # if cond_expr为可选项
[表达式 for语句 if语句（条件表达式）] # if语句（条件表达式）为可选项
'''
# 例4-11 分别从两个列表中 取不相等的两个元素 组合成元组类型元素的 新列表。
print([(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y])
# 上述代码等价于：
combs = []  # 定义一个空列表combs
for x in [1, 2, 3]:  # 对列表[1, 2, 3]遍历并赋值给x,所以x为1,2,3
    for y in [3, 1, 4]:  # 对列表[3, 1, 4]遍历并赋值给y,所以y为3,1,4
        if x != y:  # 判断条件，当x不等于y时
            combs.append((x, y))  # 在空列表combs的末尾添加由x和y组成的元组（x,y)
print(combs)

# 例4-12 利用列表解析语句生成九九乘法表元组元素的列表
s = [(x, y, x * y) for x in range(1, 10) for y in range(1, 10) if x >= y]
# if x >= y语句的限定，使得乘积结果一样的元组不重复输出，
# 比如3*2=6和2*3=6的结果一样，基于x >= y的条件限定，只输出3*2=6这一元组结果
print(s)

# 4.元组打包与解包：在打包时，我们将值放入新元组中，而在解包时，我们将这些值提取回变量。
tup_1 = "a", "b", "c", "d"  # 元组打包：将值放入新元组中
print(tup_1)
e, f, g, h = tup_1  # 元组解包：我们将元组的值提取回变量，等号左边是变量名，可以用括号括起来
# 变量名与元组的值一一对应，即将等于号右侧元组中的元素按顺序依次赋给等号左边的变量
print(e)
print(f)
print(g)
print(h)
